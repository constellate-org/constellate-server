# This code is autogenerated by Constellate, and changes made here will not persist.
#constellate: setup

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import colorcet as cc
from scipy import stats
import scipy

IS_DARK = False
plt.style.use(['rho', 'rho-dark' if IS_DARK else 'rho-light'])

c1, c2, c3, c4, c5, c6, *cs = plt.rcParams['axes.prop_cycle'].by_key()['color']
#constellate: setup

posterior = stats.johnsonsu(a=3, b=2, loc=3)
xx = np.linspace(-5, 5, 1000)
post_yy = posterior.pdf(xx)
proposal = lambda u: stats.norm(loc=u, scale=2)

x0 = 0.5
x1 = -1
#constellate: setup_panel
import panel as pn
import param
import bokeh

pn.extension('gridstack')

from panel.layout.gridstack import GridStack

def proposal(u):
    return stats.norm(loc=u, scale=2)


class Metropolis(param.Parameterized):
    samples = param.List(class_=float)
    curr = param.Number(x0)
    has_next = param.Boolean(False)
    next_x = param.Number(x1)
    messages = param.List(class_=str)
    colorMode = param.ObjectSelector(["dark", "light"])

    def __init__(self):
        super().__init__()
        if 'colorMode' in pn.state.session_args:
            self.colorMode = pn.state.session_args["colorMode"][0].decode(
            ).lower()
        else:
            self.colorMode = 'dark'

    @pn.depends("colorMode")
    def colors_theme(self):
        if self.colorMode == "light":
            plt.style.use("rho-light")
        else:
            plt.style.use("rho-dark")
        colors = plt.rcParams["axes.prop_cycle"].by_key()["color"]
        theme = bokeh.themes.Theme(
            f"/home/nicholas/programs/rho/themes/panel/eui/{self.colorMode}.yml"
        )
        return (colors, theme)

    @pn.depends("samples", "curr", "has_next", "next_x", "colorMode")
    def plot(self):
        (c1, c2, c3, c4, c5, c6, *cs), theme = self.colors_theme()
        ymax = max(post_yy) * 1.1
        p = bokeh.plotting.figure(
            title=f"Metropolis-Hastings",
            x_range=(-5.1, 5.1),
            y_range=(max(post_yy) * -0.05, ymax),
        )

        p.line(x=xx,
               y=post_yy,
               width=2,
               legend_label="True Distribution",
               color=c2)
        p.circle(x=self.curr,
                 y=posterior.pdf(self.curr),
                 radius=0.05,
                 color=c2)
        p.add_layout(
            bokeh.models.Label(
                x=self.curr,
                y=posterior.pdf(self.curr),
                text="Current",
                text_align="center",
                x_offset=-30,
                y_offset=10,
            ))

        prop_yy = proposal(self.curr).pdf(xx)
        prop_scale = 0.25 * ymax / max(prop_yy)
        prop_yy *= prop_scale
        prop_xx = xx[prop_yy >= 0.001]
        prop_yy = prop_yy[prop_yy >= 0.001]
        p.line(x=prop_xx,
               y=prop_yy,
               width=2,
               color=c1,
               legend_label="Proposal")

        if self.has_next:
            next_y = proposal(self.curr).pdf(self.next_x) * prop_scale
            p.circle(x=self.next_x, y=next_y, radius=0.05, color=c1)
            p.add_layout(
                bokeh.models.Label(
                    x=self.next_x,
                    y=next_y,
                    text="Proposed",
                    text_align="left",
                    x_offset=10,
                    y_offset=0,
                ))
            p.add_layout(
                bokeh.models.Span(
                    location=self.next_x,
                    dimension="height",
                    line_width=1,
                    line_color=c1,
                ))

        p.legend.location = "top_left"

        return pn.pane.Bokeh(p, sizing_mode="stretch_both", theme=theme)

    def step(self):
        if self.has_next:
            alpha = posterior.pdf(self.next_x) / posterior.pdf(self.curr)
            u = np.random.rand()
            self.messages.append(f"α = {alpha:.2f}, u = {u:.2f}")
            if u < alpha:
                self.messages.append(f"u < α, accepting {alpha:.2f}")
                self.samples.append(self.curr)
                self.curr = self.next_x
            else:
                self.messages.append(f"u > α, rejecting {alpha:.2f}")
                self.samples.append(self.curr)
            self.has_next = False
        else:
            self.next_x = proposal(self.curr).rvs()
            self.has_next = True

    @pn.depends("messages", "samples", "next_x")
    def history(self):
        return pn.Column(
            pn.pane.Markdown("\n\n".join(self.messages[::-1]),
                             sizing_mode="stretch_width"),
            sizing_mode="stretch_width",
            scroll=False,
        )

    # @pn.depends("messages", "samples", "colorMode")
    @pn.depends("samples", "curr", "has_next", "next_x", "colorMode")
    def sample_hist(self):
        (c1, c2, c3, c4, c5, c6, *cs), theme = self.colors_theme()
        p = bokeh.plotting.figure(
            title="Sampled Values ",
            tools="",
        )
        hist, edges = np.histogram(self.samples,
                                   range=(-5.1, 5.1),
                                   bins=15,
                                   density=True)
        p.quad(
            top=hist,
            bottom=0,
            left=edges[:-1],
            right=edges[1:],
            fill_color=c1,
            alpha=0.5,
        )
        return pn.pane.Bokeh(p, theme=theme, sizing_mode="stretch_both")


met = Metropolis()
btn = pn.widgets.Button(name="Step", button_type="default")
btn.on_click(lambda _evt: met.step())

play_btn = pn.widgets.Button(name="Toggle Play/Pause", button_type="primary")

callback = pn.io.callbacks.PeriodicCallback(period=400, callback=met.step)


def toggle(_evt):
    callback.running = not callback.running


play_btn.on_click(toggle)

pn.config.raw_css = []

grid = GridStack(sizing_mode="stretch_both")
grid[0:6, 0:8] = met.plot
grid[6:12, 0:8] = met.sample_hist
grid[0:2, 8:12] = pn.Row(play_btn, btn)
grid[2:12, 8:12] = met.history

grid.servable('Metropolis-Hastings')
